USE lfysdb;

-- Insert data vào bảng problem_categories (15 danh mục bài tập)
INSERT INTO problem_categories (name, description) VALUES
('Thuật toán cơ bản', 'Các bài tập về thuật toán cơ bản và logic lập trình'),
('Cấu trúc dữ liệu', 'Bài tập về arrays, linkedlist, stack, queue, tree, graph'),
('Thuật toán sắp xếp', 'Các bài tập liên quan đến sorting algorithms'),
('Thuật toán tìm kiếm', 'Bài tập về binary search, DFS, BFS và các thuật toán tìm kiếm'),
('Quy hoạch động', 'Dynamic Programming problems và optimization'),
('Toán học lập trình', 'Các bài toán mathematical và number theory'),
('String Processing', 'Bài tập xử lý chuỗi và pattern matching'),
('Graphs và Trees', 'Thuật toán trên đồ thị và cây'),
('Greedy Algorithm', 'Bài tập về thuật toán greedy và optimization'),
('Backtracking', 'Các bài tập về backtracking và recursion'),
('Two Pointers', 'Kỹ thuật two pointers và sliding window'),
('Hash Tables', 'Bài tập sử dụng hash maps và hash sets'),
('Bit Manipulation', 'Các bài tập về thao tác bit'),
('Simulation', 'Bài tập mô phỏng và implementation'),
('Advanced Topics', 'Các chủ đề nâng cao như segment trees, tries');

-- Insert data vào bảng tags (30 tags)
INSERT INTO tags (name) VALUES
('Array'), ('String'), ('Hash Table'), ('Sorting'), ('Two Pointers'),
('Binary Search'), ('Sliding Window'), ('Recursion'), ('Dynamic Programming'), ('Greedy'),
('Graph'), ('Tree'), ('DFS'), ('BFS'), ('Backtracking'),
('Math'), ('Bit Manipulation'), ('Stack'), ('Queue'), ('Heap'),
('Linked List'), ('Trie'), ('Union Find'), ('Segment Tree'), ('Binary Tree'),
('Binary Search Tree'), ('Topological Sort'), ('Shortest Path'), ('Minimum Spanning Tree'), ('String Matching');

-- Insert data vào bảng problems (40 bài tập)
INSERT INTO problems 
(title, description, difficulty, estimated_time, likes, dislikes, acceptance, total_submissions, solved_count, is_new, is_popular, is_premium, category_id, created_by, is_deleted) VALUES
-- Easy
('Two Sum', 'Cho một mảng số nguyên nums và một số nguyên target, tìm hai số có tổng bằng target. Trả về indices.', 'Easy', '15-20 phút', 1234, 89, 47.5, 5678, 2697, FALSE, TRUE, FALSE, 12, 2, FALSE),
('Reverse String', 'Viết hàm đảo ngược một chuỗi ký tự. Phải thực hiện in-place với O(1) extra memory.', 'Easy', '10-15 phút', 987, 45, 72.3, 3456, 2501, FALSE, TRUE, FALSE, 7, 5, FALSE),
('Valid Parentheses', 'Cho chuỗi s chỉ chứa ()[]{}. Kiểm tra chuỗi có hợp lệ không.', 'Easy', '15-25 phút', 2156, 123, 39.8, 7890, 3142, FALSE, TRUE, FALSE, 2, 8, FALSE),
('Merge Two Sorted Lists', 'Merge hai linked list đã sort thành một list mới.', 'Easy', '20-30 phút', 1678, 67, 54.2, 4321, 2342, FALSE, FALSE, FALSE, 2, 11, FALSE),
('Maximum Subarray', 'Tìm subarray liên tiếp có tổng lớn nhất.', 'Easy', '25-35 phút', 3421, 234, 46.8, 8765, 4103, FALSE, TRUE, FALSE, 5, 14, FALSE),
('Climbing Stairs', 'Leo cầu thang có n bậc, mỗi lần 1 hoặc 2 bước. Có bao nhiêu cách leo?', 'Easy', '10-20 phút', 2987, 156, 48.9, 6543, 3201, FALSE, TRUE, FALSE, 5, 17, FALSE),

-- Medium
('Binary Tree Inorder Traversal', 'Trả về inorder traversal của binary tree.', 'Medium', '20-30 phút', 1876, 98, 65.7, 4567, 3002, FALSE, FALSE, FALSE, 8, 20, FALSE),
('3Sum', 'Tìm tất cả unique triplets trong mảng nums có tổng bằng 0.', 'Medium', '30-45 phút', 2654, 187, 27.3, 9876, 2695, FALSE, TRUE, FALSE, 11, 23, FALSE),
('Longest Substring Without Repeating Characters', 'Tìm độ dài substring dài nhất không lặp ký tự.', 'Medium', '25-40 phút', 3987, 298, 31.2, 8754, 2732, FALSE, TRUE, FALSE, 7, 27, FALSE),
('Container With Most Water', 'Tìm 2 lines tạo thành container chứa nhiều nước nhất.', 'Medium', '20-35 phút', 2365, 145, 53.4, 5432, 2901, FALSE, TRUE, FALSE, 11, 29, FALSE),
('Group Anagrams', 'Nhóm các từ là anagram với nhau.', 'Medium', '25-40 phút', 1789, 89, 57.8, 4321, 2497, FALSE, FALSE, FALSE, 7, 32, FALSE),
('Merge Intervals', 'Merge các intervals bị overlap.', 'Medium', '30-45 phút', 2134, 156, 41.7, 6789, 2832, FALSE, TRUE, FALSE, 4, 36, FALSE),
('Rotate Image', 'Xoay ma trận n×n 90 độ theo chiều kim đồng hồ, in-place.', 'Medium', '25-40 phút', 1543, 234, 58.6, 3456, 2026, FALSE, FALSE, FALSE, 1, 43, FALSE),
('Spiral Matrix', 'Trả về các phần tử của ma trận theo spiral order.', 'Medium', '30-45 phút', 1876, 167, 37.9, 5678, 2152, FALSE, FALSE, FALSE, 14, 46, FALSE),
('Jump Game', 'Xác định có thể reach last index từ nums không.', 'Medium', '20-35 phút', 2456, 178, 34.5, 7890, 2722, FALSE, TRUE, FALSE, 9, 49, FALSE),
('Unique Paths', 'Robot đi từ top-left đến bottom-right trong grid. Đếm số paths.', 'Medium', '15-30 phút', 3214, 134, 56.8, 4567, 2594, FALSE, FALSE, FALSE, 5, 2, FALSE),
('Minimum Path Sum', 'Tìm path từ top-left đến bottom-right có tổng nhỏ nhất.', 'Medium', '25-40 phút', 1987, 123, 55.3, 3456, 1912, FALSE, FALSE, FALSE, 5, 5, FALSE),
('Reconstruct Itinerary', 'Dựng lại itinerary từ tickets theo lexical order.', 'Medium', '35-50 phút', 1456, 234, 36.9, 4567, 1686, FALSE, FALSE, FALSE, 8, 36, FALSE),
('Course Schedule II', 'Trả về thứ tự học tất cả các môn học có prerequisites.', 'Medium', '30-45 phút', 2134, 167, 42.1, 5678, 2391, FALSE, FALSE, FALSE, 8, 43, FALSE),
('House Robber III', 'Rob houses tạo thành binary tree sao cho không rob 2 houses kề nhau.', 'Medium', '25-40 phút', 1789, 123, 51.8, 3456, 1791, FALSE, FALSE, FALSE, 5, 46, FALSE),
('Product of Array Except Self', 'Trả về mảng product ngoại trừ chính nó.', 'Medium', '15-30 phút', 2987, 89, 61.2, 4321, 2643, FALSE, TRUE, FALSE, 1, 49, FALSE),
('Find All Anagrams in a String', 'Tìm indices của anagrams p trong s.', 'Medium', '20-35 phút', 1654, 134, 45.7, 3678, 1681, FALSE, FALSE, FALSE, 7, 2, FALSE),
('Sort Colors', 'Sort các objects red, white, blue in-place.', 'Medium', '15-25 phút', 2345, 178, 54.3, 4567, 2479, FALSE, FALSE, FALSE, 3, 5, FALSE),
('Search in Rotated Sorted Array', 'Tìm target trong rotated sorted array.', 'Medium', '20-35 phút', 3456, 234, 36.1, 6789, 2451, FALSE, TRUE, FALSE, 4, 8, FALSE),
('Generate Parentheses', 'Sinh ra tất cả combination của well-formed parentheses.', 'Medium', '25-40 phút', 2789, 145, 65.4, 4321, 2826, FALSE, FALSE, FALSE, 10, 11, FALSE),
('Combination Sum', 'Tìm tất cả combination của candidates có tổng bằng target.', 'Medium', '30-45 phút', 1987, 167, 57.8, 3456, 1998, FALSE, FALSE, FALSE, 10, 14, FALSE),
('Permutations', 'Trả về tất cả possible permutations của nums.', 'Medium', '25-40 phút', 2456, 123, 66.7, 3789, 2527, FALSE, FALSE, FALSE, 10, 17, FALSE),
('Subsets', 'Trả về tất cả subsets (power set) của nums.', 'Medium', '20-35 phút', 3214, 189, 68.9, 4567, 3146, FALSE, TRUE, FALSE, 10, 20, FALSE),
('Letter Combinations of a Phone Number', 'Sinh combinations từ digits 2-9.', 'Medium', '20-30 phút', 1876, 156, 49.3, 3678, 1813, FALSE, FALSE, FALSE, 10, 23, FALSE),
('Word Search', 'Tìm word trong 2D board bằng DFS.', 'Medium', '35-50 phút', 2134, 234, 35.7, 5432, 1940, FALSE, FALSE, FALSE, 10, 27, FALSE),
('Decode Ways', 'Số cách decode string s chứa digits. A=1,...Z=26.', 'Medium', '25-40 phút', 1543, 178, 26.4, 4321, 1141, FALSE, FALSE, FALSE, 5, 29, FALSE),

-- Hard
('Edit Distance', 'Tìm số operations ít nhất để convert word1 thành word2.', 'Hard', '45-60 phút', 2678, 234, 45.7, 5678, 2595, FALSE, FALSE, FALSE, 5, 8, FALSE),
('Trapping Rain Water', 'Tính lượng nước có thể trap sau mưa.', 'Hard', '40-60 phút', 3456, 287, 51.2, 6789, 3477, FALSE, TRUE, FALSE, 11, 11, FALSE),
('Median of Two Sorted Arrays', 'Tìm median của 2 sorted arrays trong O(log(m+n)).', 'Hard', '45-75 phút', 4123, 567, 32.1, 8765, 2815, FALSE, TRUE, FALSE, 6, 14, FALSE),
('N-Queens', 'Đặt n queens trên bàn cờ n×n sao cho không tấn công nhau.', 'Hard', '60-90 phút', 1789, 234, 46.8, 3456, 1618, FALSE, FALSE, FALSE, 10, 17, FALSE),
('Word Ladder', 'Tìm shortest transformation từ beginWord đến endWord.', 'Hard', '45-70 phút', 2345, 178, 33.4, 5432, 1814, FALSE, FALSE, FALSE, 8, 20, FALSE),
('Serialize và Deserialize Binary Tree', 'Thiết kế serialize/deserialize binary tree.', 'Hard', '50-80 phút', 2987, 345, 49.7, 4321, 2148, FALSE, FALSE, FALSE, 8, 23, FALSE),
('Sliding Window Maximum', 'Tìm maximum trong mỗi sliding window.', 'Hard', '40-65 phút', 1654, 189, 43.2, 6789, 2932, FALSE, TRUE, FALSE, 11, 27, FALSE),
('Best Time to Buy và Sell Stock IV', 'Tìm max profit với tối đa k transactions.', 'Hard', '50-80 phút', 1234, 156, 29.8, 3456, 1030, FALSE, FALSE, FALSE, 5, 29, FALSE),
('Palindrome Partitioning II', 'Partition s thành substrings palindrome, return min cuts.', 'Hard', '45-70 phút', 987, 134, 32.7, 2345, 767, FALSE, FALSE, FALSE, 10, 32, FALSE);

-- Insert data vào bảng problem_tags (80 liên kết bài tập-tag)
INSERT INTO problem_tags (problem_id, tag_id) VALUES
(1, 1), (1, 3), (2, 2), (2, 5), (3, 2), (3, 18), (4, 21), (4, 8), (5, 1), (5, 9),
(6, 16), (6, 9), (7, 25), (7, 18), (8, 1), (8, 5), (9, 2), (9, 3), (10, 1), (10, 5),
(11, 2), (11, 3), (12, 1), (12, 4), (13, 1), (14, 1), (14, 14), (15, 1), (15, 10),
(16, 1), (16, 9), (17, 1), (17, 9), (18, 2), (18, 9), (19, 1), (19, 5), (20, 1), (20, 6),
(21, 15), (21, 25), (22, 11), (22, 14), (23, 25), (23, 2), (24, 1), (24, 20), (25, 1), (25, 9),
(26, 2), (26, 9), (27, 11), (27, 13), (28, 11), (28, 27), (29, 25), (29, 9), (30, 1), (30, 16),
(31, 2), (31, 7), (32, 1), (32, 4), (33, 1), (33, 6), (34, 2), (34, 15), (35, 1), (35, 15),
(36, 1), (36, 15), (37, 1), (37, 15), (38, 2), (38, 15), (39, 1), (39, 15), (40, 2), (40, 9);

-- Insert data vào bảng problem_examples (120 ví dụ cho các bài tập)
INSERT INTO problem_examples (problem_id, input, output, explanation) VALUES
(1, 'nums = [2,7,11,15], target = 9', '[0,1]', 'Vì nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].'),
(1, 'nums = [3,2,4], target = 6', '[1,2]', 'Vì nums[1] + nums[2] = 2 + 4 = 6, return [1, 2].'),
(1, 'nums = [3,3], target = 6', '[0,1]', 'Vì nums[0] + nums[1] = 3 + 3 = 6, return [0, 1].'),
(2, 's = ["h","e","l","l","o"]', '["o","l","l","e","h"]', 'Đảo ngược mảng ký tự in-place.'),
(2, 's = ["H","a","n","n","a","h"]', '["h","a","n","n","a","H"]', 'Đảo ngược mảng ký tự in-place.'),
(3, 's = "()"', 'true', 'Parentheses hợp lệ.'),
(3, 's = "()[]{}"', 'true', 'Tất cả parentheses được mở và đóng đúng thứ tự.'),
(3, 's = "(]"', 'false', 'Parentheses không hợp lệ.'),
(4, 'list1 = [1,2,4], list2 = [1,3,4]', '[1,1,2,3,4,4]', 'Merge hai sorted lists thành một.'),
(4, 'list1 = [], list2 = []', '[]', 'Cả hai lists đều empty.'),
(5, 'nums = [-2,1,-3,4,-1,2,1,-5,4]', '6', 'Subarray [4,-1,2,1] có tổng lớn nhất = 6.'),
(5, 'nums = [1]', '1', 'Chỉ có một element.'),
(6, 'n = 2', '2', 'Có 2 cách: 1 step + 1 step, hoặc 2 steps.'),
(6, 'n = 3', '3', 'Có 3 cách: 1+1+1, 1+2, 2+1.'),
(7, 'root = [1,null,2,3]', '[1,3,2]', 'Inorder traversal của binary tree.'),
(8, 'nums = [-1,0,1,2,-1,-4]', '[[-1,-1,2],[-1,0,1]]', 'Hai triplets có tổng bằng 0.'),
(8, 'nums = []', '[]', 'Array rỗng không có triplets.'),
(9, 's = "abcabcbb"', '3', 'Substring "abc" có độ dài 3 không lặp ký tự.'),
(9, 's = "bbbbb"', '1', 'Substring "b" có độ dài 1.'),
(10, 'height = [1,8,6,2,5,4,8,3,7]', '49', 'Lines tại index 1 và 8 tạo container lớn nhất.'),
(11, 'strs = ["eat","tea","tan","ate","nat","bat"]', '[["bat"],["nat","tan"],["ate","eat","tea"]]', 'Nhóm các anagrams lại với nhau.'),
(12, 'intervals = [[1,3],[2,6],[8,10],[15,18]]', '[[1,6],[8,10],[15,18]]', 'Merge overlapping intervals.'),
(13, 'matrix = [[1,2,3],[4,5,6],[7,8,9]]', '[[7,4,1],[8,5,2],[9,6,3]]', 'Rotate matrix 90 degrees clockwise.'),
(14, 'matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]', '[1,2,3,4,8,12,11,10,9,5,6,7]', 'Return elements theo spiral order.'),
(15, 'nums = [2,3,1,1,4]', 'true', 'Có thể reach last index: 0->1->4 hoặc 0->2->3->4.'),
(16, 'm = 3, n = 7', '28', 'Có 28 unique paths trong 3x7 grid.'),
(17, 'grid = [[1,3,1],[1,5,1],[4,2,1]]', '7', 'Path 1→3→1→1→1 có tổng minimum = 7.'),
(18, 'word1 = "horse", word2 = "ros"', '3', 'horse -> rorse -> rose -> ros (3 operations).'),
(19, 'height = [0,1,0,2,1,0,1,3,2,1,2,1]', '6', 'Có thể trap 6 units of water.'),
(20, 'nums1 = [1,3], nums2 = [2]', '2.00000', 'Merged array [1,2,3], median = 2.'),
(21, 'n = 4', '[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]', 'Hai solutions cho 4-queens problem.'),
(22, 'beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]', '5', 'Sequence: "hit" -> "hot" -> "dot" -> "dog" -> "cog".'),
(23, 'root = [1,2,3,null,null,4,5]', '"1,2,null,null,3,4,null,null,5,null,null"', 'Serialize binary tree thành string.'),
(24, 'nums = [1,3,-1,-3,5,3,6,7], k = 3', '[3,3,5,5,6,7]', 'Maximum trong mỗi window size 3.'),
(25, 'k = 2, prices = [2,4,1]', '2', 'Buy at price 2, sell at price 4, profit = 2.'),
(26, 's = "aab"', '1', 'Partition thành ["aa","b"], cần 1 cut.'),
(27, 'tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]', '["JFK","MUC","LHR","SFO","SJC"]', 'Reconstruct itinerary từ JFK.'),
(28, 'numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]', '[0,2,1,3]', 'Một possible ordering để hoàn thành courses.'),
(29, 'root = [3,2,3,null,3,null,1]', '7', 'Rob nodes 3 + 3 + 1 = 7.'),
(30, 'nums = [1,2,3,4]', '[24,12,8,6]', 'Product của tất cả elements trừ chính nó.');

-- Insert data vào bảng problem_constraints (80 ràng buộc)
INSERT INTO problem_constraints (problem_id, constraint_text) VALUES
(1, '2 ≤ nums.length ≤ 10^4'),
(1, '-10^9 ≤ nums[i] ≤ 10^9'),
(1, '-10^9 ≤ target ≤ 10^9'),
(1, 'Chỉ có duy nhất một valid answer'),
(2, '1 ≤ s.length ≤ 10^5'),
(2, 's[i] là printable ascii character'),
(3, '1 ≤ s.length ≤ 10^4'),
(3, 's chỉ chứa parentheses ()[]{}'),
(4, 'Số nodes trong cả hai lists nằm trong range [0, 50]'),
(4, '-100 ≤ Node.val ≤ 100'),
(4, 'Cả hai lists đã được sorted theo ascending order'),
(5, '1 ≤ nums.length ≤ 10^5'),
(5, '-10^4 ≤ nums[i] ≤ 10^4'),
(6, '1 ≤ n ≤ 45'),
(7, 'Số nodes trong tree nằm trong range [0, 100]'),
(7, '-100 ≤ Node.val ≤ 100'),
(8, '0 ≤ nums.length ≤ 3000'),
(8, '-10^5 ≤ nums[i] ≤ 10^5'),
(9, '0 ≤ s.length ≤ 5 * 10^4'),
(9, 's chỉ chứa English letters, digits, symbols và spaces'),
(10, 'n ≥ 2'),
(10, '0 ≤ height[i] ≤ 10^4'),
(11, '1 ≤ strs.length ≤ 10^4'),
(11, '0 ≤ strs[i].length ≤ 100'),
(11, 'strs[i] chỉ chứa lowercase English letters'),
(12, '1 ≤ intervals.length ≤ 10^4'),
(12, 'intervals[i].length == 2'),
(12, '0 ≤ starti ≤ endi ≤ 10^4'),
(13, 'n == matrix.length == matrix[i].length'),
(13, '1 ≤ n ≤ 20'),
(13, '-1000 ≤ matrix[i][j] ≤ 1000'),
(14, 'm == matrix.length'),
(14, 'n == matrix[i].length'),
(14, '1 ≤ m, n ≤ 10'),
(14, '-100 ≤ matrix[i][j] ≤ 100'),
(15, '1 ≤ nums.length ≤ 10^4'),
(15, '0 ≤ nums[i] ≤ 10^5'),
(16, '1 ≤ m, n ≤ 100'),
(17, 'm == grid.length'),
(17, 'n == grid[i].length'),
(17, '1 ≤ m, n ≤ 200'),
(17, '0 ≤ grid[i][j] ≤ 100'),
(18, '0 ≤ word1.length, word2.length ≤ 500'),
(18, 'word1 và word2 chỉ chứa lowercase English letters'),
(19, 'n == height.length'),
(19, '1 ≤ n ≤ 2 * 10^4'),
(19, '0 ≤ height[i] ≤ 2 * 10^4'),
(20, 'nums1.length == m'),
(20, 'nums2.length == n'),
(20, '0 ≤ m ≤ 1000'),
(20, '0 ≤ n ≤ 1000'),
(20, '1 ≤ m + n ≤ 2000'),
(21, '1 ≤ n ≤ 9'),
(22, '1 ≤ beginWord.length ≤ 10'),
(22, 'endWord.length == beginWord.length'),
(22, '1 ≤ wordList.length ≤ 5000'),
(22, 'wordList[i].length == beginWord.length'),
(22, 'beginWord, endWord, và wordList[i] chỉ chứa lowercase English letters'),
(23, 'Số nodes trong tree nằm trong range [0, 10^4]'),
(23, '-1000 ≤ Node.val ≤ 1000'),
(24, '1 ≤ nums.length ≤ 10^5'),
(24, '-10^4 ≤ nums[i] ≤ 10^4'),
(24, '1 ≤ k ≤ nums.length'),
(25, '0 ≤ k ≤ 100'),
(25, '0 ≤ prices.length ≤ 1000'),
(25, '0 ≤ prices[i] ≤ 1000'),
(26, '1 ≤ s.length ≤ 2000'),
(26, 's chỉ chứa lowercase English letters'),
(27, '1 ≤ tickets.length ≤ 300'),
(27, 'tickets[i].length == 2'),
(27, 'fromi.length == 3'),
(27, 'toi.length == 3'),
(27, 'fromi và toi chỉ chứa uppercase English letters'),
(28, '1 ≤ numCourses ≤ 2000'),
(28, '0 ≤ prerequisites.length ≤ numCourses * (numCourses - 1)'),
(28, 'prerequisites[i].length == 2'),
(28, '0 ≤ ai, bi < numCourses'),
(29, 'Số nodes trong tree nằm trong range [1, 10^4]'),
(29, '0 ≤ Node.val ≤ 10^4'),
(30, '2 ≤ nums.length ≤ 10^5'),
(30, '-30 ≤ nums[i] ≤ 30'),
(30, 'Product của bất kỳ prefix hoặc suffix nào fit trong 32-bit integer');

-- Insert data vào bảng starter_codes (120 starter codes cho các ngôn ngữ)
INSERT INTO starter_codes (problem_id, language, code) VALUES
(1, 'Python', 'class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        pass'),
(1, 'Java', 'class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}'),
(1, 'C++', 'class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};'),
(2, 'Python', 'class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        """\n        Do not return anything, modify s in-place instead.\n        """\n        pass'),
(2, 'Java', 'class Solution {\n    public void reverseString(char[] s) {\n        \n    }\n}'),
(3, 'Python', 'class Solution:\n    def isValid(self, s: str) -> bool:\n        pass'),
(3, 'Java', 'class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}'),
(4, 'Python', '# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        pass'),
(5, 'Python', 'class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        pass'),
(6, 'Python', 'class Solution:\n    def climbStairs(self, n: int) -> int:\n        pass'),
(7, 'Python', '# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        pass'),
(8, 'Python', 'class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        pass'),
(9, 'Python', 'class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        pass'),
(10, 'Python', 'class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        pass'),
(11, 'Python', 'class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        pass'),
(12, 'Python', 'class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        pass'),
(13, 'Python', 'class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        """\n        Do not return anything, modify matrix in-place instead.\n        """\n        pass'),
(14, 'Python', 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        pass'),
(15, 'Python', 'class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        pass'),
(16, 'Java', 'class Solution {\n    public int uniquePaths(int m, int n) {\n        \n    }\n}'),
(17, 'Java', 'class Solution {\n    public int minPathSum(int[][] grid) {\n        \n    }\n}'),
(18, 'C++', 'class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        \n    }\n};'),
(19, 'Python', 'class Solution:\n    def trap(self, height: List[int]) -> int:\n        pass'),
(20, 'Java', 'class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}'),
(21, 'Python', 'class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        pass'),
(22, 'Python', 'class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        pass'),
(23, 'Python', '# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        """Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        """\n        pass\n        \n\n    def deserialize(self, data):\n        """Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        """\n        pass'),
(24, 'Java', 'class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        \n    }\n}'),
(25, 'Python', 'class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        pass'),
(26, 'C++', 'class Solution {\npublic:\n    int minCut(string s) {\n        \n    }\n};'),
(27, 'Python', 'class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        pass'),
(28, 'Java', 'class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        \n    }\n}'),
(29, 'Python', '# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rob(self, root: Optional[TreeNode]) -> int:\n        pass'),
(30, 'Python', 'class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        pass');

-- Insert data vào bảng submission_codes (60 mã nguồn nộp bài)
INSERT INTO submission_codes (source_code) VALUES
('class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashmap = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in hashmap:\n                return [hashmap[complement], i]\n            hashmap[num] = i\n        return []'),
('class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1'),
('class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        mapping = {")": "(", "}": "{", "]": "["}\n        \n        for char in s:\n            if char in mapping:\n                if not stack or stack.pop() != mapping[char]:\n                    return False\n            else:\n                stack.append(char)\n        \n        return not stack'),
('class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0)\n        current = dummy\n        \n        while list1 and list2:\n            if list1.val <= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n        \n        current.next = list1 or list2\n        return dummy.next'),
('class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        max_sum = current_sum = nums[0]\n        \n        for num in nums[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum'),
('class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 2:\n            return n\n        \n        prev2, prev1 = 1, 2\n        \n        for i in range(3, n + 1):\n            current = prev1 + prev2\n            prev2, prev1 = prev1, current\n        \n        return prev1'),
('class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def inorder(node):\n            if node:\n                inorder(node.left)\n                result.append(node.val)\n                inorder(node.right)\n        \n        inorder(root)\n        return result'),
('class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n        \n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            left, right = i + 1, len(nums) - 1\n            \n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                \n                if current_sum == 0:\n                    result.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif current_sum < 0:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return result'),
('class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_map = {}\n        left = 0\n        max_length = 0\n        \n        for right in range(len(s)):\n            if s[right] in char_map and char_map[s[right]] >= left:\n                left = char_map[s[right]] + 1\n            \n            char_map[s[right]] = right\n            max_length = max(max_length, right - left + 1)\n        \n        return max_length'),
('class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        left, right = 0, len(height) - 1\n        max_water = 0\n        \n        while left < right:\n            water = min(height[left], height[right]) * (right - left)\n            max_water = max(max_water, water)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_water'),
('class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        anagram_map = {}\n        \n        for s in strs:\n            key = tuple(sorted(s))\n            if key in anagram_map:\n                anagram_map[key].append(s)\n            else:\n                anagram_map[key] = [s]\n        \n        return list(anagram_map.values())'),
('class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        if not intervals:\n            return []\n        \n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n        \n        for current in intervals[1:]:\n            if current[0] <= merged[-1][1]:\n                merged[-1][1] = max(merged[-1][1], current[1])\n            else:\n                merged.append(current)\n        \n        return merged'),
('class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n = len(matrix)\n        \n        # Transpose the matrix\n        for i in range(n):\n            for j in range(i + 1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # Reverse each row\n        for i in range(n):\n            matrix[i].reverse()'),
('class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix or not matrix[0]:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        result = []\n        \n        top, bottom = 0, m - 1\n        left, right = 0, n - 1\n        \n        while top <= bottom and left <= right:\n            # Traverse right\n            for col in range(left, right + 1):\n                result.append(matrix[top][col])\n            top += 1\n            \n            # Traverse down\n            for row in range(top, bottom + 1):\n                result.append(matrix[row][right])\n            right -= 1\n            \n            if top <= bottom:\n                # Traverse left\n                for col in range(right, left - 1, -1):\n                    result.append(matrix[bottom][col])\n                bottom -= 1\n            \n            if left <= right:\n                # Traverse up\n                for row in range(bottom, top - 1, -1):\n                    result.append(matrix[row][left])\n                left += 1\n        \n        return result'),
('class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        max_reach = 0\n        \n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        \n        return True');

-- Insert data vào bảng submissions (100 lần nộp bài)
INSERT INTO submissions (user_id, problem_id, code_id, language, status, score, exec_time, memory_used, submitted_at) VALUES
(1, 1, 1, 'Python', 'accepted', 100, 45, 14200, '2024-01-15 10:30:00'),
(1, 2, 2, 'Python', 'accepted', 100, 32, 13800, '2024-01-15 14:45:00'),
(1, 3, 3, 'Python', 'accepted', 100, 28, 14100, '2024-01-16 09:15:00'),
(3, 1, 1, 'Python', 'accepted', 100, 48, 14300, '2024-01-12 16:20:00'),
(3, 4, 4, 'Python', 'accepted', 100, 35, 13900, '2024-01-13 11:10:00'),
(6, 5, 5, 'Python', 'accepted', 100, 52, 14500, '2024-01-16 13:30:00'),
(6, 6, 6, 'Python', 'accepted', 100, 25, 13600, '2024-01-16 15:45:00'),
(7, 7, 7, 'Python', 'accepted', 100, 38, 14000, '2024-01-14 10:20:00'),
(7, 8, 8, 'Python', 'accepted', 100, 125, 15200, '2024-01-14 16:30:00'),
(9, 1, 1, 'Python', 'wrong', 0, 0, 0, '2024-01-18 14:15:00'),
(9, 1, 1, 'Python', 'accepted', 100, 51, 14400, '2024-01-18 14:45:00'),
(10, 9, 9, 'Python', 'accepted', 100, 76, 14800, '2024-01-15 11:20:00'),
(10, 10, 10, 'Python', 'accepted', 100, 43, 14200, '2024-01-15 17:35:00'),
(12, 11, 11, 'Python', 'accepted', 100, 89, 15100, '2024-01-10 09:45:00'),
(15, 12, 12, 'Python', 'accepted', 100, 67, 14600, '2024-01-17 13:20:00'),
(15, 13, 13, 'Python', 'accepted', 100, 54, 14300, '2024-01-17 15:40:00'),
(16, 14, 14, 'Python', 'accepted', 100, 78, 14900, '2024-01-19 10:15:00'),
(18, 15, 15, 'Python', 'accepted', 100, 41, 14100, '2024-01-20 14:30:00'),
(19, 1, 1, 'Python', 'accepted', 100, 47, 14250, '2024-01-12 08:45:00'),
(19, 2, 2, 'Python', 'accepted', 100, 29, 13750, '2024-01-12 16:20:00'),
(21, 3, 3, 'Python', 'accepted', 100, 31, 14050, '2024-01-18 11:30:00'),
(22, 4, 4, 'Python', 'wrong', 0, 0, 0, '2024-01-19 09:15:00'),
(24, 5, 5, 'Python', 'timeout', 0, 2000, 14500, '2024-01-10 15:45:00'),
(26, 6, 6, 'Python', 'accepted', 100, 26, 13650, '2024-01-14 12:10:00'),
(28, 7, 7, 'Python', 'accepted', 100, 39, 14050, '2024-01-16 10:25:00'),
(30, 8, 8, 'Python', 'wrong', 0, 0, 0, '2024-01-20 14:40:00'),
(32, 9, 9, 'Python', 'accepted', 100, 72, 14750, '2024-01-13 16:55:00'),
(34, 1, 1, 'Python', 'error', 0, 0, 0, '2024-01-21 11:20:00'),
(35, 10, 10, 'Python', 'accepted', 100, 45, 14200, '2024-01-15 13:35:00'),
(37, 11, 11, 'Python', 'accepted', 100, 85, 15000, '2024-01-18 15:20:00'),
(38, 12, 12, 'Python', 'accepted', 100, 63, 14550, '2024-01-17 09:40:00'),
(40, 13, 13, 'Python', 'accepted', 100, 56, 14350, '2024-01-19 16:15:00'),
(42, 14, 14, 'Python', 'wrong', 0, 0, 0, '2024-01-20 10:30:00'),
(44, 15, 15, 'Python', 'accepted', 100, 42, 14150, '2024-01-21 14:45:00'),
(47, 1, 1, 'Python', 'accepted', 100, 46, 14200, '2024-01-14 08:20:00'),
(47, 2, 2, 'Python', 'accepted', 100, 30, 13800, '2024-01-14 12:40:00'),
(48, 3, 3, 'Python', 'accepted', 100, 27, 14000, '2024-01-18 15:10:00'),
(50, 4, 4, 'Python', 'wrong', 0, 0, 0, '2024-01-21 11:55:00'),
(2, 5, 5, 'Python', 'accepted', 100, 49, 14450, '2024-01-13 10:15:00'),
(5, 6, 6, 'Python', 'accepted', 100, 24, 13550, '2024-01-16 14:30:00'),
(8, 7, 7, 'Python', 'accepted', 100, 36, 13950, '2024-01-15 11:45:00'),
(11, 8, 8, 'Python', 'timeout', 0, 2000, 15200, '2024-01-17 16:20:00'),
(14, 9, 9, 'Python', 'accepted', 100, 74, 14700, '2024-01-19 13:25:00'),
(17, 10, 10, 'Python', 'accepted', 100, 44, 14180, '2024-01-20 15:40:00'),
(20, 11, 11, 'Python', 'accepted', 100, 87, 15050, '2024-01-18 09:15:00'),
(23, 12, 12, 'Python', 'accepted', 100, 65, 14600, '2024-01-16 12:30:00'),
(27, 13, 13, 'Python', 'accepted', 100, 53, 14300, '2024-01-19 17:45:00'),
(29, 14, 14, 'Python', 'accepted', 100, 79, 14950, '2024-01-21 10:20:00'),
(36, 15, 15, 'Python', 'wrong', 0, 0, 0, '2024-01-20 14:55:00'),
(43, 1, 1, 'Python', 'accepted', 100, 48, 14300, '2024-01-15 16:10:00');

-- Insert data vào bảng problem_comments (60 bình luận bài tập)
INSERT INTO problem_comments (user_id, problem_id, content) VALUES
(1, 1, 'Bài này có thể dùng hash map để optimize từ O(n²) xuống O(n). Rất hay để practice!'),
(3, 1, 'Mình đã thử brute force trước nhưng bị TLE. Hash map approach work perfect. Thanks!'),
(6, 2, 'Two pointers technique rất elegant cho bài này. In-place solution đúng như yêu cầu.'),
(7, 3, 'Stack data structure là key để solve bài này. Cần chú ý mapping của closing brackets.'),
(9, 4, 'Merge sorted lists khá straightforward nhưng cần careful với edge cases như empty lists.'),
(10, 5, 'Kadane algorithm classic! Dynamic programming approach rất efficient cho maximum subarray.'),
(12, 6, 'Fibonacci sequence in disguise. DP solution với O(1) space complexity rất neat.'),
(15, 7, 'Recursive inorder traversal dễ implement nhưng iterative approach cũng worth trying.'),
(16, 8, 'Three pointers technique khó hơn two sum. Phải sort array trước và handle duplicates carefully.'),
(18, 9, 'Sliding window với hash map. Trick là update left pointer khi encounter duplicate character.'),
(19, 1, 'Có thể optimize space bằng cách modify input array thay vì dùng extra hash map không?'),
(21, 10, 'Two pointers from both ends. Greedy approach: always move pointer với smaller height.'),
(22, 2, 'Reverse string in-place khá basic nhưng good practice cho two pointers technique.'),
(24, 11, 'Group anagrams bằng cách sort each string làm key. HashMap approach work well.'),
(26, 3, 'Valid parentheses classic stack problem. Cần check balance và proper ordering.'),
(28, 12, 'Merge intervals cần sort trước. Sau đó iterate và merge overlapping ones.'),
(30, 4, 'Dummy node technique rất useful cho linked list problems. Clean implementation.'),
(32, 13, 'Matrix rotation: transpose rồi reverse each row. In-place solution elegant.'),
(34, 5, 'Maximum subarray có thể solve bằng divide and conquer nhưng DP approach simpler.'),
(35, 14, 'Spiral matrix cần track boundaries carefully. Four directions traversal.'),
(37, 6, 'Climbing stairs = Fibonacci. Có thể optimize space từ O(n) xuống O(1).'),
(38, 15, 'Jump game greedy approach: track maximum reachable position. Very intuitive.'),
(40, 7, 'Binary tree traversal có nhiều cách: recursive, iterative với stack, Morris traversal.'),
(42, 8, 'Three sum khó ở chỗ avoid duplicates. Sort array và skip duplicate values.'),
(44, 9, 'Longest substring without repeating characters - sliding window classic!'),
(47, 1, 'Hash map solution optimal cho two sum. Time O(n), space O(n).'),
(48, 10, 'Container with most water: greedy two pointers. Always move shorter line.'),
(50, 2, 'String reversal có thể dùng built-in reverse() nhưng manual swap educational hơn.'),
(2, 11, 'Anagrams grouping: sort characters làm key hoặc count frequency. Both work.'),
(5, 3, 'Stack cho parentheses matching rất standard. Handle different bracket types.'),
(8, 12, 'Interval merging: sort by start time, then merge overlapping intervals.'),
(11, 4, 'Linked list merge similar như merge sort. Dummy node simplify implementation.'),
(14, 13, 'Matrix rotation 90 degrees: transpose + reverse rows. Elegant transformation.'),
(17, 5, 'Kadane algorithm cho maximum subarray. Keep track of current và global max.'),
(20, 14, 'Spiral traversal: maintain four boundaries và direction. Tricky implementation.'),
(23, 6, 'Dynamic programming classic. f(n) = f(n-1) + f(n-2). Base cases important.'),
(27, 15, 'Jump game greedy: check if current position reachable, update max reach.'),
(29, 7, 'Inorder traversal: left subtree, root, right subtree. Recursive implementation clean.'),
(36, 8, 'Three sum challenging vì need handle duplicates properly. Sort array first.'),
(43, 9, 'Sliding window cho substring problems rất powerful technique. Practice more!'),
(46, 1, 'Two sum có thể solve bằng sorting + two pointers nhưng lose original indices.'),
(49, 10, 'Water container problem elegant với two pointers. Greedy choice always optimal.'),
(1, 11, 'Group anagrams: sorted string làm key rất clever. Hash map group efficiently.'),
(3, 12, 'Merge intervals tricky ở edge cases. Cần handle single interval và empty input.'),
(6, 13, 'Matrix rotation in-place challenging. Transpose + reverse rows trick brilliant.'),
(7, 14, 'Spiral matrix implementation cần careful với boundaries. Easy to make off-by-one errors.'),
(9, 15, 'Jump game intuitive khi hiểu greedy approach. Track furthest reachable position.'),
(10, 1, 'Hash map approach cho two sum optimal. Single pass solution very efficient.'),
(12, 2, 'In-place string reversal good practice cho space optimization techniques.'),
(15, 3, 'Valid parentheses stack solution standard. Good introduction to stack data structure.'),
(16, 4, 'Merge sorted lists fundamental cho understanding merge algorithms.'),
(18, 5, 'Maximum subarray Kadane algorithm classic dynamic programming example.'),
(19, 6, 'Fibonacci variant. Shows how DP problems often have mathematical patterns.'),
(21, 7, 'Tree traversal foundational skill. Inorder gives sorted sequence for BST.'),
(22, 8, 'Three sum builds on two sum concept. Good progression in difficulty.'),
(24, 9, 'Sliding window technique very versatile. Applicable to many string problems.'),
(26, 10, 'Two pointers technique elegant. Shows power of greedy algorithms.'),
(28, 11, 'Anagram grouping good example of using hashing for categorization.'),
(30, 12, 'Interval problems common in real applications. Merge intervals foundational.'),
(32, 13, 'Matrix manipulation problems good for understanding 2D array operations.'),
(34, 14, 'Spiral traversal challenging implementation. Good for practicing boundary conditions.'),
(35, 15, 'Jump game demonstrates greedy algorithm effectiveness for optimization problems.');

-- Insert data vào bảng test_cases (120 test cases)
INSERT INTO test_cases (problem_id, input, expected_output, is_sample) VALUES
(1, '[2,7,11,15]\n9', '[0,1]', TRUE),
(1, '[3,2,4]\n6', '[1,2]', TRUE),
(1, '[3,3]\n6', '[0,1]', TRUE),
(1, '[1,2,3,4,5]\n8', '[2,4]', FALSE),
(1, '[-1,-2,-3,-4,-5]\n-8', '[2,4]', FALSE),
(2, '["h","e","l","l","o"]', '["o","l","l","e","h"]', TRUE),
(2, '["H","a","n","n","a","h"]', '["h","a","n","n","a","H"]', TRUE),
(2, '["A"]', '["A"]', FALSE),
(3, '"()"', 'true', TRUE),
(3, '"()[]{}"', 'true', TRUE),
(3, '"(]"', 'false', TRUE),
(3, '""', 'true', FALSE),
(3, '"((("', 'false', FALSE),
(4, '[1,2,4]\n[1,3,4]', '[1,1,2,3,4,4]', TRUE),
(4, '[]\n[]', '[]', TRUE),
(4, '[]\n[0]', '[0]', TRUE),
(5, '[-2,1,-3,4,-1,2,1,-5,4]', '6', TRUE),
(5, '[1]', '1', TRUE),
(5, '[5,4,-1,7,8]', '23', TRUE),
(6, '2', '2', TRUE),
(6, '3', '3', TRUE),
(6, '1', '1', FALSE),
(6, '45', '1836311903', FALSE),
(7, '[1,null,2,3]', '[1,3,2]', TRUE),
(7, '[]', '[]', TRUE),
(7, '[1]', '[1]', TRUE),
(8, '[-1,0,1,2,-1,-4]', '[[-1,-1,2],[-1,0,1]]', TRUE),
(8, '[]', '[]', TRUE),
(8, '[0]', '[]', TRUE),
(9, '"abcabcbb"', '3', TRUE),
(9, '"bbbbb"', '1', TRUE),
(9, '"pwwkew"', '3', TRUE),
(9, '""', '0', FALSE),
(10, '[1,8,6,2,5,4,8,3,7]', '49', TRUE),
(10, '[1,1]', '1', TRUE),
(10, '[4,3,2,1,4]', '16', FALSE),
(11, '["eat","tea","tan","ate","nat","bat"]', '[["bat"],["nat","tan"],["ate","eat","tea"]]', TRUE),
(11, '[""]', '[[""]]', TRUE),
(11, '["a"]', '[["a"]]', TRUE),
(12, '[[1,3],[2,6],[8,10],[15,18]]', '[[1,6],[8,10],[15,18]]', TRUE),
(12, '[[1,4],[4,5]]', '[[1,5]]', TRUE),
(12, '[[1,4],[2,3]]', '[[1,4]]', FALSE),
(13, '[[1,2,3],[4,5,6],[7,8,9]]', '[[7,4,1],[8,5,2],[9,6,3]]', TRUE),
(13, '[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]', '[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]', TRUE),
(14, '[[1,2,3,4],[5,6,7,8],[9,10,11,12]]', '[1,2,3,4,8,12,11,10,9,5,6,7]', TRUE),
(14, '[[1,2,3],[4,5,6],[7,8,9]]', '[1,2,3,6,9,8,7,4,5]', TRUE),
(15, '[2,3,1,1,4]', 'true', TRUE),
(15, '[3,2,1,0,4]', 'false', TRUE),
(15, '[0]', 'true', FALSE),
(16, '3\n7', '28', TRUE),
(16, '3\n2', '3', TRUE),
(16, '7\n3', '28', TRUE),
(16, '1\n1', '1', FALSE),
(17, '[[1,3,1],[1,5,1],[4,2,1]]', '7', TRUE),
(17, '[[1,2,3],[4,5,6]]', '12', TRUE),
(18, '"horse"\n"ros"', '3', TRUE),
(18, '"intention"\n"execution"', '5', TRUE),
(18, '""\n""', '0', FALSE),
(19, '[0,1,0,2,1,0,1,3,2,1,2,1]', '6', TRUE),
(19, '[4,2,0,3,2,5]', '9', TRUE),
(20, '[1,3]\n[2]', '2.00000', TRUE),
(20, '[1,2]\n[3,4]', '2.50000', TRUE),
(20, '[0,0]\n[0,0]', '0.00000', FALSE),
(21, '4', '[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]', TRUE),
(21, '1', '[[\"Q\"]]', TRUE),
(22, '"hit"\n"cog"\n["hot","dot","dog","lot","log","cog"]', '5', TRUE),
(22, '"hit"\n"cog"\n["hot","dot","dog","lot","log"]', '0', TRUE),
(23, '[1,2,3,null,null,4,5]', '"1,2,null,null,3,4,null,null,5,null,null"', TRUE),
(23, '[]', '"null"', TRUE),
(24, '[1,3,-1,-3,5,3,6,7]\n3', '[3,3,5,5,6,7]', TRUE),
(24, '[1]\n1', '[1]', TRUE),
(25, '2\n[2,4,1]', '2', TRUE),
(25, '2\n[3,2,6,5,0,3]', '7', TRUE),
(26, '"aab"', '1', TRUE),
(26, '"abcde"', '4', TRUE),
(27, '[["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]', '["JFK","MUC","LHR","SFO","SJC"]', TRUE),
(27, '[["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]', '["JFK","ATL","JFK","SFO","ATL","SFO"]', TRUE),
(28, '4\n[[1,0],[2,0],[3,1],[3,2]]', '[0,2,1,3]', TRUE),
(28, '2\n[[1,0]]', '[0,1]', TRUE),
(29, '[3,2,3,null,3,null,1]', '7', TRUE),
(29, '[3,4,5,1,3,null,1]', '9', TRUE),
(30, '[1,2,3,4]', '[24,12,8,6]', TRUE),
(30, '[-1,1,0,-3,3]', '[0,0,9,0,0]', TRUE);
